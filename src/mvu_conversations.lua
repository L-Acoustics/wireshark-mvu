--[[
	Copyright (c) 2025 by L-Acoustics.

	This file is part of the Milan Vendor Unique plugin for Wireshark
	---
		Keeps track of information of visited packets for inter-packet analysis
		A conversation is a collection of packets with the same values for the
		following IEEE 1722.1 fields:
		  - Controller entity ID
		  - Sequence ID
	---

	Authors: Benjamin Landrot

	Licensed under the GNU General Public License (GPL) version 2
	you may not use this file except in compliance with the License.
	You may obtain a copy of the License at

		https://www.gnu.org/licenses/old-licenses/gpl-2.0.en.html

	Unless required by applicable law or agreed to in writing, software
	distributed under the License is distributed on an "AS IS" BASIS,
	WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express of implied.
	See the License for the specific language governing permissions and
	limitations under the License.

]]

-- Require dependency modules
local mIEEE17221Specs = require("ieee17221_specs")
local mIEEE17221Fields = require("ieee17221_fields")

-- Init module object
local m = {}

---------------------
-- Private Members --
---------------------

--- Table of information stored per AECP conversation
m._conversations = {}

--- List of error message generated by frame number during registering
m._register_error_messages = {}

--------------------
-- Public Methods --
--------------------

--- Clear all conversations
function m.ClearConversations()
	-- Clear the conversations table
	m._conversations = {}
	--- Clear error message
	m._register_error_messages = {}
end

--- Register a message and its metadata in the conversations
--- @param message_metadata table Table containing the data that we want to store for this message
--- @param frame_number number The frame number in the packet capture
--- @return string|nil error Error message in case of problem
function m.RegisterMessage(message_metadata, frame_number)

	-----------------------------------
	-- Validate arguments and fields --
	-----------------------------------

	-- Data table
	if type(message_metadata) ~= "table" then
		return
	end

	-- Controller entity ID
	if type(frame_number) ~= "number" then
		return
	end

	-- Read IEEE 1722.1 fields
	local controller_entity_id = mIEEE17221Fields.GetControllerEntityId()
	local sequence_id          = mIEEE17221Fields.GetSequenceId()
	local message_type         = mIEEE17221Fields.GetMessageType()

	-- Controller entity ID
	if type(controller_entity_id) ~= "string" then
		return
	end

	-- Sequence ID
	if type(sequence_id) ~= "number" then
		return
	end

	-- Message type
	if type(message_type) ~= "number" or mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type] == nil then
		return
	end

	--------------
	-- Register --
	--------------

	-- Create entry for controller entity if needed
	if m._conversations[controller_entity_id] == nil then
		m._conversations[controller_entity_id] = {}
	end

	-- Create entry for sequence ID if needed
	if m._conversations[controller_entity_id][sequence_id] == nil then
		m._conversations[controller_entity_id][sequence_id] = {}
	end

	-- If an entry already exists for this message type
	if m._conversations[controller_entity_id][sequence_id][message_type] ~= nil then

		-- Get frame number of previously parsed packet
		local previous_frame_number = m._conversations[controller_entity_id][sequence_id][message_type].frameNumber

		-- Build error message
		local error_message = "Another packet"
			.. (type(previous_frame_number) == "number" and " (frame number "..previous_frame_number..")" or "")
			.. " with this controller entity ID ("..controller_entity_id.."),"
			.. " sequence ID ("..sequence_id..")"
			.. " and message type ("..mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type]..")"
			.. " was already parsed."

		-- Save the error message for when the packet gets visited again later
		m._register_error_messages[frame_number] = error_message

		-- Return the error message
		return error_message

	-- If no entry exists yet for this message type
	else
		-- Create an entry and assign it to the provided data table
		m._conversations[controller_entity_id][sequence_id][message_type] = message_metadata
	end

end

--- Get the error message possibly generated during the call to RegisterMessage()
--- when the packet was first visited
--- @param frame_number number The frame number of the associated packet
--- @return string|nil error Error message in case there was a problem during registering
function m.GetRegisterErrorMessageForFrame(frame_number)
	-- Validate argument
	if type(frame_number) ~= "number" then
		return
	end
	-- Return the error message if any
	return m._register_error_messages[frame_number]
end

--- Read stored data for a conversation message type
--- @param message_type number|nil The message type (VENDOR_UNIQUE_COMMAND or VENDOR_UNIQUE_RESPONSE). If nil, the message type of the currently visited packet is considered.
--- @return table|nil message_metadata Table containing the data that was stored for this message
function m.GetConversationMessageData(message_type)

	-- Read IEEE 1722.1 fields
	local controller_entity_id = mIEEE17221Fields.GetControllerEntityId()
	local sequence_id          = mIEEE17221Fields.GetSequenceId()
	local actual_message_type  = message_type and message_type or mIEEE17221Fields.GetMessageType()

	-- If an entry exists for this controller entity ID
	if type(controller_entity_id) == "string" and type(m._conversations[controller_entity_id]) == "table" then
		-- If an entry exists for this sequence ID
		if type(sequence_id) == "number" and type(m._conversations[controller_entity_id][sequence_id]) == "table" then
			-- Return the data stored for the provided message type, if any
			return m._conversations[controller_entity_id][sequence_id][actual_message_type]
		end
	end

end

--- Add extra message metadata to an existing entry in the conversation
--- @param controller_entity_id string|nil The ID of the controller entity that initiated the command
--- @param sequence_id number|nil Unique sequence ID for this conversation
--- @param message_type number|nil The message type (VENDOR_UNIQUE_COMMAND or VENDOR_UNIQUE_RESPONSE)
--- @param added_message_metadata table Table containing the data that we want to add for this message
function m.AddMessageDataToConversation(controller_entity_id, sequence_id, message_type, added_message_metadata)

	------------------------
	-- Validate arguments --
	------------------------

	-- Controller entity ID
	if type(controller_entity_id) ~= "string" then
		return
	end

	-- Sequence ID
	if type(sequence_id) ~= "number" then
		return
	end

	-- Message type
	if type(message_type) ~= "number" or mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type] == nil then
		return
	end

	-- Data table
	if type(added_message_metadata) ~= "table" then
		return
	end

	---------------------------
	-- Fetch and update data --
	---------------------------

	-- If an entry exists for this controller_entity
	if type(m._conversations[controller_entity_id]) == "table" then
		-- If an entry exists for this sequence ID
		if type(m._conversations[controller_entity_id][sequence_id]) == "table" then
			-- Copy all properties to stored table
			for k,v in pairs(added_message_metadata) do
				m._conversations[controller_entity_id][sequence_id][message_type][k] = v
			end
		end
	end

end

-- Return module object
return m
