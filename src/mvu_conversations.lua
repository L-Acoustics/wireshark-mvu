---
--- mvu_conversations.lua
---
--- Keep strack of information of passed visited packets for inter-packet analysis
---

-- Require dependency modules
local mIEEE17221Specs = require("ieee17221_specs")

-- Init module object
local m = {}

---------------------
-- Private Members --
---------------------

--- Table of information stored per AECP conversation
m._conversations = {}

--- List of error message generated by frame number during registering
m._register_error_messages = {}

--------------------
-- Public Methods --
--------------------

--- Clear all conversations
function m.ClearConversations()
	-- Clear the conversations table
	m._conversations = {}
end

--- Register a message and its metadata in the conversation
--- @param controller_entity_id string|nil The ID of the controller entity that initiated the command
--- @param sequence_id number|nil Unique sequence ID for this conversation
--- @param message_type number|nil The message type (VENDOR_UNIQUE_COMMAND or VENDOR_UNIQUE_RESPONSE)
--- @param message_metadata table Table containing the data that we want to store for this message
--- @param frame_number number The number of the frame containing the message
--- @return string|nil error Error message in case of problem
function m.RegisterMessage(controller_entity_id, sequence_id, message_type, message_metadata, frame_number)

	------------------------
	-- Validate arguments --
	------------------------

	-- Controller entity ID
	if type(controller_entity_id) ~= "string" then
		return
	end

	-- Sequence ID
	if type(sequence_id) ~= "number" then
		return
	end

	-- Message type
	if type(message_type) ~= "number" or mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type] == nil then
		return
	end

	-- Data table
	if type(message_metadata) ~= "table" then
		return
	end

	--------------
	-- Register --
	--------------

	-- Create entry for controller entity if needed
	if m._conversations[controller_entity_id] == nil then
		m._conversations[controller_entity_id] = {}
	end

	-- Create entry for sequence ID if needed
	if m._conversations[controller_entity_id][sequence_id] == nil then
		m._conversations[controller_entity_id][sequence_id] = {}
	end

	-- If an entry already exists for this message type
	if m._conversations[controller_entity_id][sequence_id][message_type] ~= nil then

		-- Init error message
		local error_message = ""

		-- Get frame number of previosly parsed packet
		local previous_frame_number = m._conversations[controller_entity_id][sequence_id][message_type].frameNumber

		-- If previous frame number was found
		if type(previous_frame_number) == "number" then
			error_message = "Another packet (frame number "..previous_frame_number..")"
				.. " with this controller entity ID ("..controller_entity_id.."),"
				.. " sequence ID ("..sequence_id..")"
				.. " and message type ("..mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type]..")"
				.. " was already parsed."
		else
			error_message = "Another packet"
				.. " with this controller entity ID ("..controller_entity_id.."),"
				.. " sequence ID ("..sequence_id..")"
				.. " and message type ("..mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type]..")"
				.. " was already parsed."
		end

		-- Save error message
		m._register_error_messages[frame_number] = error_message

		-- Return the error message
		return error_message

	-- If no entry exists yet for this message type
	else
		-- Create an entry and assign it to the provided data table
		m._conversations[controller_entity_id][sequence_id][message_type] = message_metadata
	end

end

--- Get the error message possibly generated during the call to RegisterMessage() for this frame number
--- @param frame_number number The number of the frame containing the message
--- @return string|nil error Error message in case of problem
function m.GetRegisterErrorMessageForFrame(frame_number)
	-- Validate argument
	if type(frame_number) ~= "number" then
		return
	end
	-- Return the error message if any
	return m._register_error_messages[frame_number]
end

--- Read stored data for a conversation message type
--- @param controller_entity_id string|nil The ID of the controller entity that initiated the command
--- @param sequence_id number|nil Unique sequence ID for this conversation
--- @param message_type number|nil The message type (VENDOR_UNIQUE_COMMAND or VENDOR_UNIQUE_RESPONSE)
--- @return table|nil message_metadata Table containing the data that was stored for this message
function m.GetConversationMessageData(controller_entity_id, sequence_id, message_type)

	------------------------
	-- Validate arguments --
	------------------------

	-- Controller entity ID
	if type(controller_entity_id) ~= "string" then
		return
	end

	-- Sequence ID
	if type(sequence_id) ~= "number" then
		return
	end

	-- Message type
	if type(message_type) ~= "number" or mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type] == nil then
		return
	end

	---------------------------
	-- Fetch and return data --
	---------------------------

	-- If an entry exists for this controller_entity
	if type(m._conversations[controller_entity_id]) == "table" then
		-- If an entry exists for this sequence ID
		if type(m._conversations[controller_entity_id][sequence_id]) == "table" then
			-- Return the data stored for the provided message type
			return m._conversations[controller_entity_id][sequence_id][message_type]
		end
	end

end

--- Add extra message metadata to an existing entry in the conversation
--- @param controller_entity_id string|nil The ID of the controller entity that initiated the command
--- @param sequence_id number|nil Unique sequence ID for this conversation
--- @param message_type number|nil The message type (VENDOR_UNIQUE_COMMAND or VENDOR_UNIQUE_RESPONSE)
--- @param added_message_metadata table Table containing the data that we want to add for this message
function m.AddMessageDataToConversation(controller_entity_id, sequence_id, message_type, added_message_metadata)

	------------------------
	-- Validate arguments --
	------------------------

	-- Controller entity ID
	if type(controller_entity_id) ~= "string" then
		return
	end

	-- Sequence ID
	if type(sequence_id) ~= "number" then
		return
	end

	-- Message type
	if type(message_type) ~= "number" or mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type] == nil then
		return
	end

	-- Data table
	if type(added_message_metadata) ~= "table" then
		return
	end

	---------------------------
	-- Fetch and update data --
	---------------------------

	-- If an entry exists for this controller_entity
	if type(m._conversations[controller_entity_id]) == "table" then
		-- If an entry exists for this sequence ID
		if type(m._conversations[controller_entity_id][sequence_id]) == "table" then
			-- Copy all properties to stored table
			for k,v in pairs(added_message_metadata) do
				m._conversations[controller_entity_id][sequence_id][message_type][k] = v
			end
		end
	end

end

-- Return module object
return m
