---
--- mvu_conversations.lua
---
--- Keeps track of information of passed visited packets for inter-packet analysis
---

-- Require dependency modules
local mIEEE17221Specs = require("ieee17221_specs")
local mIEEE17221Fields = require("ieee17221_fields")

-- Init module object
local m = {}

---------------------
-- Private Members --
---------------------

--- Table of information stored per AECP conversation
m._conversations = {}

--- List of error message generated by frame number during registering
m._register_error_messages = {}

--------------------
-- Public Methods --
--------------------

--- Clear all conversations
function m.ClearConversations()
	-- Clear the conversations table
	m._conversations = {}
end

--- Register a message and its metadata in the conversations
--- @param message_metadata table Table containing the data that we want to store for this message
--- @param frame_number number The frame number in the packet capture
--- @return string|nil error Error message in case of problem
function m.RegisterMessage(message_metadata, frame_number)

	------------------------
	-- Validate arguments --
	------------------------

	-- Data table
	if type(message_metadata) ~= "table" then
		return
	end

	-- Controller entity ID
	if type(frame_number) ~= "number" then
		return
	end

	-- Read IEEE 1722.1 fields
	local controller_entity_id = mIEEE17221Fields.GetControllerEntityId()
	local sequence_id          = mIEEE17221Fields.GetSequenceId()
	local message_type         = mIEEE17221Fields.GetMessageType()

	-- Controller entity ID
	if type(controller_entity_id) ~= "string" then
		return
	end

	-- Sequence ID
	if type(sequence_id) ~= "number" then
		return
	end

	-- Message type
	if type(message_type) ~= "number" or mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type] == nil then
		return
	end

	--------------
	-- Register --
	--------------

	-- Create entry for controller entity if needed
	if m._conversations[controller_entity_id] == nil then
		m._conversations[controller_entity_id] = {}
	end

	-- Create entry for sequence ID if needed
	if m._conversations[controller_entity_id][sequence_id] == nil then
		m._conversations[controller_entity_id][sequence_id] = {}
	end

	-- If an entry already exists for this message type
	if m._conversations[controller_entity_id][sequence_id][message_type] ~= nil then

		-- Get frame number of previously parsed packet
		local previous_frame_number = m._conversations[controller_entity_id][sequence_id][message_type].frameNumber

		-- Build error message
		local error_message = "Another packet"
			.. (type(previous_frame_number) == "number" and " (frame number "..previous_frame_number..")" or "")
			.. " with this controller entity ID ("..controller_entity_id.."),"
			.. " sequence ID ("..sequence_id..")"
			.. " and message type ("..mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type]..")"
			.. " was already parsed."

		-- Save the error message for when the packet gets visited again later
		m._register_error_messages[frame_number] = error_message

		-- Return the error message
		return error_message

	-- If no entry exists yet for this message type
	else
		-- Create an entry and assign it to the provided data table
		m._conversations[controller_entity_id][sequence_id][message_type] = message_metadata
	end

end

--- Get the error message possibly generated during the call to RegisterMessage() when the packet was first visited
--- @param frame_number number The frame number of the associated packet
--- @return string|nil error Error message in case there was a problem during registering
function m.GetRegisterErrorMessageForFrame(frame_number)
	-- Validate argument
	if type(frame_number) ~= "number" then
		return
	end
	-- Return the error message if any
	return m._register_error_messages[frame_number]
end

--- Read stored data for a conversation message type
--- @param message_type number|nil The message type (VENDOR_UNIQUE_COMMAND or VENDOR_UNIQUE_RESPONSE). If nil, the message type of the currently visited packet is considered.
--- @return table|nil message_metadata Table containing the data that was stored for this message
function m.GetConversationMessageData(message_type)

	-- Read IEEE 1722.1 fields
	local controller_entity_id = mIEEE17221Fields.GetControllerEntityId()
	local sequence_id          = mIEEE17221Fields.GetSequenceId()
	local actual_message_type  = message_type and message_type or mIEEE17221Fields.GetMessageType()

	-- If an entry exists for this controller_entity
	if type(controller_entity_id) == "string" and type(m._conversations[controller_entity_id]) == "table" then
		-- If an entry exists for this sequence ID
		if type(sequence_id) == "number" and type(m._conversations[controller_entity_id][sequence_id]) == "table" then
			-- Return the data stored for the provided message type
			return m._conversations[controller_entity_id][sequence_id][actual_message_type]
		end
	end

end

--- Add extra message metadata to an existing entry in the conversation
--- @param controller_entity_id string|nil The ID of the controller entity that initiated the command
--- @param sequence_id number|nil Unique sequence ID for this conversation
--- @param message_type number|nil The message type (VENDOR_UNIQUE_COMMAND or VENDOR_UNIQUE_RESPONSE)
--- @param added_message_metadata table Table containing the data that we want to add for this message
function m.AddMessageDataToConversation(controller_entity_id, sequence_id, message_type, added_message_metadata)

	------------------------
	-- Validate arguments --
	------------------------

	-- Controller entity ID
	if type(controller_entity_id) ~= "string" then
		return
	end

	-- Sequence ID
	if type(sequence_id) ~= "number" then
		return
	end

	-- Message type
	if type(message_type) ~= "number" or mIEEE17221Specs.AECP_MESSAGE_TYPES[message_type] == nil then
		return
	end

	-- Data table
	if type(added_message_metadata) ~= "table" then
		return
	end

	---------------------------
	-- Fetch and update data --
	---------------------------

	-- If an entry exists for this controller_entity
	if type(m._conversations[controller_entity_id]) == "table" then
		-- If an entry exists for this sequence ID
		if type(m._conversations[controller_entity_id][sequence_id]) == "table" then
			-- Copy all properties to stored table
			for k,v in pairs(added_message_metadata) do
				m._conversations[controller_entity_id][sequence_id][message_type][k] = v
			end
		end
	end

end

-- Return module object
return m
